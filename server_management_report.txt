Server Management Directory Report
Generated on: Sat Jan 11 10:13:30 PM EST 2025
===================================

Directory Structure and Permissions:
-----------------------------------
drwxrwxr-x 9 brett brett 4096 Jan 11 16:10 /home/brett/server-management
drwxrwxr-x 2 brett brett 4096 Jan  1 12:19 /home/brett/server-management/templates
-rw-rw-r-- 1 brett brett 1354 Dec 23 20:40 /home/brett/server-management/templates/manage.html
-rw-rw-r-- 1 brett brett 960 Dec 22 16:02 /home/brett/server-management/templates/base.html
-rw-r--r-- 1 brett brett 5023 Dec 30 19:15 /home/brett/server-management/templates/dashboard.html
-rw-r--r-- 1 brett brett 1170 Dec 22 16:03 /home/brett/server-management/templates/clients.html
drwxrwxr-x 4 brett brett 4096 Dec 27 22:10 /home/brett/server-management/migrations
-rw-rw-r-- 1 brett brett 38 Dec 27 22:08 /home/brett/server-management/migrations/README
-rw-rw-r-- 1 brett brett 635 Dec 27 22:08 /home/brett/server-management/migrations/script.py.mako
drwxrwxr-x 2 brett brett 4096 Dec 27 22:08 /home/brett/server-management/migrations/versions
-rw-rw-r-- 1 brett brett 2103 Dec 27 22:08 /home/brett/server-management/migrations/env.py
-rwxr-xr-x 1 brett brett 1812 Jan  5 22:27 /home/brett/server-management/generate_server_report.sh
-rw-r--r-- 1 root root 5658 Jan 11 15:57 /home/brett/server-management/refactor.py
-rw-r--r-- 1 brett brett 2762 Dec 22 15:54 /home/brett/server-management/organize_files.py
-rw-r--r-- 1 root root 1624 Jan  5 20:31 /home/brett/server-management/README.md
-rw-rw-r-- 1 brett brett 3705 Dec 27 22:10 /home/brett/server-management/alembic.ini
-rw-rw-r-- 1 brett brett 411 Jan 11 16:10 /home/brett/server-management/app.py
-rw-r--r-- 1 brett brett 872 Jan 11 11:57 /home/brett/server-management/initialize_db.py
drwxr-xr-x 3 brett brett 4096 Dec 23 10:32 /home/brett/server-management/static
-rw-r--r-- 1 brett brett 591 Dec 23 10:32 /home/brett/server-management/static/styles.css
drwxr-xr-x 2 brett brett 4096 Dec 22 16:04 /home/brett/server-management/static/css
-rw-rw-r-- 1 brett brett 2512 Jan 11 16:02 /home/brett/server-management/db.py
-rw-r--r-- 1 root root 955 Jan 11 16:03 /home/brett/server-management/models.py
-rw-rw-r-- 1 brett brett 401 Jan 11 16:06 /home/brett/server-management/scheduler.py
-rw-rw-r-- 1 brett brett 6 Jan  5 20:24 /home/brett/server-management/.gitignore
drwxrwxr-x 3 brett brett 4096 Jan 11 17:49 /home/brett/server-management/api
-rw-rw-r-- 1 brett brett 5259 Jan 11 17:49 /home/brett/server-management/api/endpoints.py

File Contents:
-----------------------------------
-----------------------------------
File: /home/brett/server-management/templates/manage.html
-----------------------------------
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Client Management Dashboard</title>
    <link rel="stylesheet" href="/static/styles.css">
</head>
<body>
    <header>
        <h1>Client Management Dashboard</h1>
    </header>
    <main>
        <table>
            <thead>
                <tr>
                    <th>Name</th>
                    <th>IP Address</th>
                    <th>State</th>
                    <th>Actions</th>
                </tr>
            </thead>
<tbody>
    {% if clients %}
        {% for client in clients %}
        <tr>
            <td>{{ client[0] }}</td> <!-- Name -->
            <td>{{ client[1] }}</td> <!-- IP -->
            <td>{{ client[2] }}</td> <!-- State -->
            <td>
                <form method="post" action="/block/{{ client[0] }}">
                    <button type="submit">Block</button>
                </form>
                <form method="post" action="/unblock/{{ client[0] }}">
                    <button type="submit">Unblock</button>
                </form>
            </td>
        </tr>
        {% endfor %}
    {% else %}
        <tr>
            <td colspan="4">No clients found.</td>
        </tr>
    {% endif %}
</tbody>
        </table>
    </main>
</body>
</html>

-----------------------------------
File: /home/brett/server-management/templates/base.html
-----------------------------------
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}Client Management{% endblock %}</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/styles.css">
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container-fluid">
            <a class="navbar-brand" href="/">Client Management</a>
            <div class="navbar-nav">
                <a class="nav-link" href="/clients">Clients</a>
            </div>
        </div>
    </nav>
    <div class="container mt-4">
        {% block content %}{% endblock %}
    </div>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/scripts.js"></script>
</body>
</html>

-----------------------------------
File: /home/brett/server-management/templates/dashboard.html
-----------------------------------
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Internet Control Dashboard</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            background-color: #f5f5f5;
        }
        h1 {
            color: #007bff;
            margin-bottom: 20px;
        }
        .table {
            background-color: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }
        th {
            background-color: #007bff;
            color: white;
            text-align: center;
            vertical-align: middle;
        }
        td {
            text-align: center;
            vertical-align: middle;
        }
        .form-control-sm {
            max-width: 200px;
        }
        .btn-sm {
            width: 120px;
        }
        .btn-primary, .btn-secondary, .btn-danger, .btn-success, .btn-warning {
            margin-top: 5px;
        }
        .input-group input {
            text-align: center;
        }
    </style>
</head>
<body>
<div class="container mt-5">
    <h1 class="text-center">Internet Control Dashboard</h1>

    <!-- Error/Feedback Messages -->
    <div id="error-message" class="alert alert-danger" style="display: none;"></div>
    <div id="success-message" class="alert alert-success" style="display: none;"></div>

    <!-- Client Table -->
    <table class="table table-striped table-bordered mt-4">
        <thead>
        <tr>
            <th>Client Name</th>
            <th>Friendly Name</th>
            <th>IP Address</th>
            <th>State</th>
            <th>Downtime Schedule</th>
            <th>Actions</th>
        </tr>
        </thead>
        <tbody>
        {% for client in clients %}
        <tr>
            <!-- Client Name -->
            <td>{{ client.name }}</td>
            
            <!-- Friendly Name -->
            <td>
                <form method="post" action="/clients/rename" class="d-inline">
                    <input type="hidden" name="client_id" value="{{ client.client_id }}">
                    <input type="text" name="new_name" class="form-control form-control-sm"
                           value="{{ client.friendly_name or '' }}" placeholder="Set friendly name">
                    <button class="btn btn-secondary btn-sm mt-2" type="submit">Update</button>
                </form>
            </td>
            
            <!-- IP Address -->
            <td>{{ client.ip }}</td>
            
            <!-- Client State -->
            <td>
                {% if client.state == "unpaused" %}
                <span class="badge bg-success">Active</span>
                {% else %}
                <span class="badge bg-danger">Paused</span>
                {% endif %}
            </td>
            
            <!-- Downtime Schedule -->
            <td>
                <form method="post" action="/schedule">
                    <input type="hidden" name="client_id" value="{{ client.client_id }}">
                    <div class="input-group input-group-sm">
                        <input type="time" name="disable_time" class="form-control"
                               value="{{ client.schedules[0].disable_time if client.schedules else '' }}" required>
                        <input type="time" name="enable_time" class="form-control"
                               value="{{ client.schedules[0].enable_time if client.schedules else '' }}" required>
                        <button class="btn btn-primary btn-sm" type="submit">Set</button>
                    </div>
                </form>
            </td>
            
            <!-- Actions -->
            <td>
                <form method="post" action="/control" class="d-inline">
                    <input type="hidden" name="client_id" value="{{ client.client_id }}">
                    <input type="hidden" name="pause" value="true">
                    <button class="btn btn-danger btn-sm">Pause</button>
                </form>
                <form method="post" action="/control" class="d-inline">
                    <input type="hidden" name="client_id" value="{{ client.client_id }}">
                    <input type="hidden" name="pause" value="false">
                    <button class="btn btn-success btn-sm">Unpause</button>
                </form>
                <form method="post" action="/clients/delete" class="d-inline">
                    <input type="hidden" name="client_id" value="{{ client.client_id }}">
                    <button class="btn btn-warning btn-sm">Delete</button>
                </form>
            </td>
        </tr>
        {% endfor %}
        </tbody>
    </table>
</div>

<!-- Include Bootstrap JavaScript -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>

-----------------------------------
File: /home/brett/server-management/templates/clients.html
-----------------------------------
{% extends "base.html" %}
{% block title %}Manage Clients{% endblock %}
{% block content %}
<h2>Clients</h2>
<table class="table table-striped">
    <thead>
        <tr>
            <th>Name</th>
            <th>IP</th>
            <th>Last Seen</th>
            <th>Status</th>
            <th>Action</th>
        </tr>
    </thead>
    <tbody>
        {% for client in clients %}
        <tr>
            <td>{{ client.name }}</td>
            <td>{{ client.ip }}</td>
            <td>{{ client.last_seen }}</td>
            <td>{{ client.status }}</td>
            <td>
                <form action="/clients/control" method="post" class="d-inline">
                    <input type="hidden" name="name" value="{{ client.name }}">
                    <select name="action" class="form-select form-select-sm">
                        <option value="pause">Pause</option>
                        <option value="unpause">Unpause</option>
                    </select>
                    <button type="submit" class="btn btn-primary btn-sm">Submit</button>
                </form>
            </td>
        </tr>
        {% endfor %}
    </tbody>
</table>
{% endblock %}

-----------------------------------
File: /home/brett/server-management/migrations/README
-----------------------------------
Generic single-database configuration.
-----------------------------------
File: /home/brett/server-management/migrations/script.py.mako
-----------------------------------
"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision: str = ${repr(up_revision)}
down_revision: Union[str, None] = ${repr(down_revision)}
branch_labels: Union[str, Sequence[str], None] = ${repr(branch_labels)}
depends_on: Union[str, Sequence[str], None] = ${repr(depends_on)}


def upgrade() -> None:
    ${upgrades if upgrades else "pass"}


def downgrade() -> None:
    ${downgrades if downgrades else "pass"}

-----------------------------------
File: /home/brett/server-management/migrations/env.py
-----------------------------------
from logging.config import fileConfig

from sqlalchemy import engine_from_config
from sqlalchemy import pool

from alembic import context

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
target_metadata = None

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    connectable = engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection, target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()

-----------------------------------
File: /home/brett/server-management/generate_server_report.sh
-----------------------------------
#!/bin/bash

# Define the directory to scan and the output file
TARGET_DIR="/home/brett/server-management"
OUTPUT_FILE="server_management_report.txt"

# Start the report
{
    echo "Server Management Directory Report"
    echo "Generated on: $(date)"
    echo "==================================="
    echo ""
} > "$OUTPUT_FILE"

# Verify the directory exists
if [ ! -d "$TARGET_DIR" ]; then
    echo "Error: Directory $TARGET_DIR does not exist." >> "$OUTPUT_FILE"
    echo "Report generation failed." >> "$OUTPUT_FILE"
    exit 1
fi

# List directory structure and permissions, excluding specific directories and files
{
    echo "Directory Structure and Permissions:"
    echo "-----------------------------------"
    find "$TARGET_DIR" \
        -path "$TARGET_DIR/venv" -prune -o \
        -path "*/__pycache__" -prune -o \
        -path "*/.git" -prune -o \
        -name "$(basename "$OUTPUT_FILE")" -prune -o \
        -name "*.db" -prune -o \
        -exec ls -ld {} \;
    echo ""
} >> "$OUTPUT_FILE"

# Include file contents for all files, excluding specific directories and files
{
    echo "File Contents:"
    echo "-----------------------------------"
    find "$TARGET_DIR" \
        -path "$TARGET_DIR/venv" -prune -o \
        -path "*/__pycache__" -prune -o \
        -path "*/.git" -prune -o \
        -name "$(basename "$OUTPUT_FILE")" -prune -o \
        -name "*.db" -prune -o \
        -type f -print | while IFS= read -r file; do
        echo "-----------------------------------"
        echo "File: $file"
        echo "-----------------------------------"
        if [ -r "$file" ]; then
            cat "$file"
        else
            echo "Error: File not readable."
        fi
        echo ""
    done
} >> "$OUTPUT_FILE"

# Notify the user
echo "Report generated: $OUTPUT_FILE"

-----------------------------------
File: /home/brett/server-management/refactor.py
-----------------------------------
import os
import sys
import subprocess
from pathlib import Path

# Directories and files
BASE_DIR = Path(__file__).parent
FILES = {
    "app.py": """from fastapi import FastAPI
from api.endpoints import router
from scheduler import scheduler

app = FastAPI()

# Include all API endpoints
app.include_router(router)

@app.on_event("startup")
async def startup_event():
    scheduler.start()
    print("Scheduler started and application is running.")
""",
    "models.py": """from sqlalchemy import Column, Integer, String, DateTime, ForeignKey
from sqlalchemy.orm import relationship
from datetime import datetime
from db import Base

class Client(Base):
    __tablename__ = "clients"
    id = Column(Integer, primary_key=True, index=True)
    client_id = Column(String, unique=True, nullable=False)
    ip = Column(String, nullable=False)
    state = Column(String, default="unpaused")
    registered_at = Column(DateTime, default=datetime.utcnow)
    last_heartbeat = Column(DateTime)
    schedules = relationship("Schedule", back_populates="client", cascade="all, delete-orphan")

class Schedule(Base):
    __tablename__ = "schedules"
    id = Column(Integer, primary_key=True, index=True)
    client_id = Column(Integer, ForeignKey("clients.id"), nullable=False)
    disable_time = Column(String, nullable=False)
    enable_time = Column(String, nullable=False)
    client = relationship("Client", back_populates="schedules")
""",
    "api/endpoints.py": """from fastapi import APIRouter, HTTPException, Depends
from sqlalchemy.orm import Session
from pydantic import BaseModel
from datetime import datetime
from db import SessionLocal
from models import Client, Schedule

router = APIRouter()

class ClientRegistration(BaseModel):
    client_id: str
    ip: str

class HeartbeatUpdate(BaseModel):
    client_id: str
    ip: str

class ScheduleUpdate(BaseModel):
    client_id: str
    disable_time: str
    enable_time: str

@router.post("/clients/register")
async def register_client(data: ClientRegistration, db: Session = Depends(SessionLocal)):
    try:
        existing_client = db.query(Client).filter(Client.client_id == data.client_id).first()
        if existing_client:
            existing_client.ip = data.ip
            existing_client.last_heartbeat = datetime.utcnow()
        else:
            new_client = Client(
                client_id=data.client_id,
                ip=data.ip,
                state="unpaused",
                registered_at=datetime.utcnow(),
                last_heartbeat=datetime.utcnow()
            )
            db.add(new_client)
        db.commit()
        return {"status": "success", "client_id": data.client_id}
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Failed to register client: {str(e)}")

@router.post("/clients/heartbeat")
async def update_heartbeat(data: HeartbeatUpdate, db: Session = Depends(SessionLocal)):
    try:
        client = db.query(Client).filter(Client.client_id == data.client_id).first()
        if not client:
            raise HTTPException(status_code=404, detail="Client not registered.")
        client.ip = data.ip
        client.last_heartbeat = datetime.utcnow()
        db.commit()
        return {"status": "success"}
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Failed to update heartbeat: {str(e)}")

@router.post("/schedule")
async def set_schedule(data: ScheduleUpdate, db: Session = Depends(SessionLocal)):
    try:
        datetime.strptime(data.disable_time, "%H:%M")
        datetime.strptime(data.enable_time, "%H:%M")
    except ValueError:
        raise HTTPException(status_code=400, detail="Invalid time format.")

    client = db.query(Client).filter(Client.client_id == data.client_id).first()
    if not client:
        raise HTTPException(status_code=404, detail="Client not found.")

    schedule = db.query(Schedule).filter(Schedule.client_id == client.id).first()
    if schedule:
        schedule.disable_time = data.disable_time
        schedule.enable_time = data.enable_time
    else:
        schedule = Schedule(
            client_id=client.id,
            disable_time=data.disable_time,
            enable_time=data.enable_time
        )
        db.add(schedule)

    db.commit()
    return {"status": "success"}
""",
    "scheduler.py": """from apscheduler.schedulers.asyncio import AsyncIOScheduler
scheduler = AsyncIOScheduler()

scheduler.start()
"""
}

# Step 1: Write or Replace Files
def write_files():
    print("Writing files...")
    for filename, content in FILES.items():
        filepath = BASE_DIR / filename
        filepath.parent.mkdir(parents=True, exist_ok=True)
        with open(filepath, "w") as file:
            file.write(content)
    print("Files written successfully.")

# Step 2: Install Dependencies
def install_dependencies():
    print("Installing dependencies...")
    subprocess.check_call([sys.executable, "-m", "pip", "install", "fastapi", "uvicorn", "sqlalchemy", "apscheduler"])
    print("Dependencies installed.")

# Step 3: Initialize Database
def initialize_database():
    print("Initializing database...")
    from db import engine, Base
    from models import Client, Schedule
    Base.metadata.create_all(bind=engine)
    print("Database initialized successfully.")

# Step 4: Run Tests
def run_tests():
    print("Running basic tests...")
    # Add client registration and scheduling test cases here
    print("Tests completed.")

if __name__ == "__main__":
    write_files()
    install_dependencies()
    initialize_database()
    run_tests()
    print("Refactor complete.")

-----------------------------------
File: /home/brett/server-management/organize_files.py
-----------------------------------
import os
import shutil

# Define the target directory structure
directory_structure = {
    "static": {
        "css": [],
        "js": []
    },
    "templates": ["base.html", "clients.html"],
    "api": ["endpoints.py"],
    "": ["app.py", "db.py", "scheduler.py"],
    "venv": [],  # Assume virtual environment already exists
}

# Source directory where all files are currently located
source_dir = "/home/brett/server-management"
# Destination directory (can be the same as source or a new one)
destination_dir = "/home/brett/server-management"

# Create the destination directory structure
def create_structure():
    print("Creating directory structure...")
    for folder, files in directory_structure.items():
        dir_path = os.path.join(destination_dir, folder)
        os.makedirs(dir_path, exist_ok=True)
        print(f"Created directory: {dir_path}")

# Move files to the correct locations
def move_files():
    print("Organizing files...")
    for folder, files in directory_structure.items():
        target_folder = os.path.join(destination_dir, folder)
        for file_name in files:
            source_file = os.path.join(source_dir, file_name)
            target_file = os.path.join(target_folder, file_name)
            if os.path.exists(source_file):
                if os.path.exists(target_file):
                    print(f"Skipping {file_name}: Already exists in {target_folder}")
                else:
                    shutil.move(source_file, target_file)
                    print(f"Moved {file_name} to {target_folder}")
            else:
                print(f"Warning: {file_name} not found in {source_dir}")

# Copy venv if exists
def copy_venv():
    source_venv = os.path.join(source_dir, "venv")
    target_venv = os.path.join(destination_dir, "venv")
    if os.path.exists(source_venv):
        if os.path.exists(target_venv):
            print("Skipping virtual environment: Already exists.")
        else:
            print("Copying virtual environment...")
            shutil.copytree(source_venv, target_venv, dirs_exist_ok=True)
            print("Virtual environment copied.")
    else:
        print("Warning: venv not found in source directory.")

if __name__ == "__main__":
    # Confirm with the user
    print(f"Source directory: {source_dir}")
    print(f"Destination directory: {destination_dir}")
    confirm = input("Proceed with organizing files? (yes/no): ").strip().lower()
    if confirm == "yes":
        # Ensure destination directory exists
        os.makedirs(destination_dir, exist_ok=True)
        
        # Execute organization
        create_structure()
        move_files()
        copy_venv()
        print("File organization complete!")
    else:
        print("Operation canceled.")

-----------------------------------
File: /home/brett/server-management/README.md
-----------------------------------
# Downtime Monitoring Application

This repository contains a Downtime Monitoring Application developed using PHP, Python, and Shell scripts. The application is designed to track the availability of various services and notify users of any downtime. It follows a server-client architecture meant to manage the downtime and internet access for Windows PCs. The functionality allows the user to set schedules for downtime and to manually pause and unpause the internet.

## Features

- **Service Monitoring**: Monitor the uptime and downtime of various services.
- **Notification System**: Notify users via email or other communication channels when a service goes down.
- **Logging**: Maintain logs of service availability for analysis and reporting.
- **Dashboard**: Provide a web interface for viewing the status of monitored services.
- **Downtime Management**: Set schedules for downtime and manage internet access for Windows PCs.
- **Manual Control**: Manually pause and unpause the internet.

## Technologies Used

- **PHP**: 72.1% - Backend for the web interface and service monitoring.
- **Python**: 27.5% - Scripts for monitoring and notifications.
- **Shell**: 0.4% - Automation scripts for deployment and maintenance.

## Installation

Follow these steps to set up the application on your local machine.

### Prerequisites

- PHP 7.x or later
- Python 3.x
- Composer (for PHP dependencies)
- pip (Python package installer)
- Web server (e.g., Apache, Nginx)
- MySQL or other supported databases

### Steps

1. **Clone the Repository**

   ```bash
   git clone https://github.com/bel52/downtime.git
   cd downtime

-----------------------------------
File: /home/brett/server-management/alembic.ini
-----------------------------------
# A generic, single database configuration.

[alembic]
# path to migration scripts
# Use forward slashes (/) also on windows to provide an os agnostic path
script_location = migrations

# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s
# Uncomment the line below if you want the files to be prepended with date and time
# see https://alembic.sqlalchemy.org/en/latest/tutorial.html#editing-the-ini-file
# for all available tokens
# file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s

# sys.path path, will be prepended to sys.path if present.
# defaults to the current working directory.
prepend_sys_path = .

# timezone to use when rendering the date within the migration file
# as well as the filename.
# If specified, requires the python>=3.9 or backports.zoneinfo library.
# Any required deps can installed by adding `alembic[tz]` to the pip requirements
# string value is passed to ZoneInfo()
# leave blank for localtime
# timezone =

# max length of characters to apply to the "slug" field
# truncate_slug_length = 40

# set to 'true' to run the environment during
# the 'revision' command, regardless of autogenerate
# revision_environment = false

# set to 'true' to allow .pyc and .pyo files without
# a source .py file to be detected as revisions in the
# versions/ directory
# sourceless = false

# version location specification; This defaults
# to migrations/versions.  When using multiple version
# directories, initial revisions must be specified with --version-path.
# The path separator used here should be the separator specified by "version_path_separator" below.
# version_locations = %(here)s/bar:%(here)s/bat:migrations/versions

# version path separator; As mentioned above, this is the character used to split
# version_locations. The default within new alembic.ini files is "os", which uses os.pathsep.
# If this key is omitted entirely, it falls back to the legacy behavior of splitting on spaces and/or commas.
# Valid values for version_path_separator are:
#
# version_path_separator = :
# version_path_separator = ;
# version_path_separator = space
# version_path_separator = newline
version_path_separator = os  # Use os.pathsep. Default configuration used for new projects.

# set to 'true' to search source files recursively
# in each "version_locations" directory
# new in Alembic version 1.10
# recursive_version_locations = false

# the output encoding used when revision files
# are written from script.py.mako
# output_encoding = utf-8
sqlalchemy.url = sqlite:///server.db


[post_write_hooks]
# post_write_hooks defines scripts or Python functions that are run
# on newly generated revision scripts.  See the documentation for further
# detail and examples

# format using "black" - use the console_scripts runner, against the "black" entrypoint
# hooks = black
# black.type = console_scripts
# black.entrypoint = black
# black.options = -l 79 REVISION_SCRIPT_FILENAME

# lint with attempts to fix using "ruff" - use the exec runner, execute a binary
# hooks = ruff
# ruff.type = exec
# ruff.executable = %(here)s/.venv/bin/ruff
# ruff.options = --fix REVISION_SCRIPT_FILENAME

# Logging configuration
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARNING
handlers = console
qualname =

[logger_sqlalchemy]
level = WARNING
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S

-----------------------------------
File: /home/brett/server-management/app.py
-----------------------------------
from fastapi import FastAPI
from api.endpoints import router
from scheduler import start_scheduler  # Import the modified scheduler logic

app = FastAPI()

# Include all API endpoints
app.include_router(router)

@app.on_event("startup")
async def startup_event():
    start_scheduler()  # Ensures the scheduler starts only if it is not already running
    print("Scheduler started and application is running.")

-----------------------------------
File: /home/brett/server-management/initialize_db.py
-----------------------------------
import sqlite3
from contextlib import closing

DB_PATH = "server.db"

def init_db():
    with closing(sqlite3.connect(DB_PATH)) as conn, conn:
        conn.executescript(
            """
CREATE TABLE IF NOT EXISTS clients (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    client_id TEXT UNIQUE NOT NULL,
    friendly_name TEXT,
    ip TEXT NOT NULL,
    state TEXT DEFAULT 'unpaused',
    registered_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_heartbeat DATETIME
);


            CREATE TABLE IF NOT EXISTS schedules (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                client_id INTEGER NOT NULL,
                disable_time TEXT NOT NULL,
                enable_time TEXT NOT NULL,
                FOREIGN KEY (client_id) REFERENCES clients (id) ON DELETE CASCADE
            );
            """
        )

if __name__ == "__main__":
    init_db()

-----------------------------------
File: /home/brett/server-management/static/styles.css
-----------------------------------
body {
    font-family: Arial, sans-serif;
    background-color: #f9f9f9;
    margin: 0;
    padding: 0;
}
header {
    background-color: #333;
    color: white;
    padding: 1em 0;
    text-align: center;
}
table {
    width: 100%;
    border-collapse: collapse;
    margin: 20px 0;
}
table, th, td {
    border: 1px solid #ddd;
}
th, td {
    padding: 8px;
    text-align: left;
}
th {
    background-color: #f4f4f4;
}
button {
    padding: 5px 10px;
    background-color: #007bff;
    color: white;
    border: none;
    cursor: pointer;
}
button:hover {
    background-color: #0056b3;
}

-----------------------------------
File: /home/brett/server-management/db.py
-----------------------------------
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from sqlalchemy.exc import SQLAlchemyError

# Define the database URL
DATABASE_URL = "sqlite:///server.db"

# Create the SQLAlchemy engine
engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})

# Define the declarative base
Base = declarative_base()

# Create a session factory
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Utility functions for database operations
def get_db():
    """
    Dependency to get the database session.
    Ensures proper cleanup after the session is used.
    """
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# Helper functions for common database operations
def add_client(client_id, ip, state="unpaused", db_session=None):
    """
    Add a new client to the database.
    """
    from models import Client
    try:
        new_client = Client(client_id=client_id, ip=ip, state=state)
        db_session.add(new_client)
        db_session.commit()
        return new_client
    except SQLAlchemyError as e:
        db_session.rollback()
        raise e

def get_client_by_id(client_id, db_session):
    """
    Retrieve a client by its unique client_id.
    """
    from models import Client
    return db_session.query(Client).filter(Client.client_id == client_id).first()

def get_all_clients(db_session):
    """
    Retrieve all clients from the database.
    """
    from models import Client
    return db_session.query(Client).all()

def add_schedule(client_id, disable_time, enable_time, db_session=None):
    """
    Add or update a schedule for a client.
    """
    from models import Schedule
    try:
        schedule = db_session.query(Schedule).filter(Schedule.client_id == client_id).first()
        if schedule:
            schedule.disable_time = disable_time
            schedule.enable_time = enable_time
        else:
            schedule = Schedule(client_id=client_id, disable_time=disable_time, enable_time=enable_time)
            db_session.add(schedule)
        db_session.commit()
        return schedule
    except SQLAlchemyError as e:
        db_session.rollback()
        raise e

def get_schedule_by_client_id(client_id, db_session):
    """
    Retrieve the schedule for a specific client.
    """
    from models import Schedule
    return db_session.query(Schedule).filter(Schedule.client_id == client_id).first()

-----------------------------------
File: /home/brett/server-management/models.py
-----------------------------------
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey
from sqlalchemy.orm import relationship
from datetime import datetime
from db import Base

class Client(Base):
    __tablename__ = "clients"
    id = Column(Integer, primary_key=True, index=True)
    client_id = Column(String, unique=True, nullable=False)
    ip = Column(String, nullable=False)
    state = Column(String, default="unpaused")
    registered_at = Column(DateTime, default=datetime.utcnow)
    last_heartbeat = Column(DateTime)
    schedules = relationship("Schedule", back_populates="client", cascade="all, delete-orphan")

class Schedule(Base):
    __tablename__ = "schedules"
    id = Column(Integer, primary_key=True, index=True)
    client_id = Column(Integer, ForeignKey("clients.id"), nullable=False)
    disable_time = Column(String, nullable=False)
    enable_time = Column(String, nullable=False)
    client = relationship("Client", back_populates="schedules")

-----------------------------------
File: /home/brett/server-management/scheduler.py
-----------------------------------
from apscheduler.schedulers.background import BackgroundScheduler
import logging

# Create a single instance of the scheduler
scheduler = BackgroundScheduler()

def start_scheduler():
    """Start the scheduler if not already running."""
    if not scheduler.running:
        scheduler.start()
        logging.info("Scheduler started.")
    else:
        logging.info("Scheduler is already running.")

-----------------------------------
File: /home/brett/server-management/.gitignore
-----------------------------------
venv/

-----------------------------------
File: /home/brett/server-management/api/endpoints.py
-----------------------------------
from fastapi import APIRouter, HTTPException, Depends
from sqlalchemy.orm import Session
from pydantic import BaseModel
from datetime import datetime
from db import SessionLocal
from models import Client, Schedule
from fastapi import WebSocket, WebSocketDisconnect
import logging

# Connected WebSocket clients dictionary
connected_clients = {}
router = APIRouter()

class ClientRegistration(BaseModel):
    client_id: str
    ip: str

class HeartbeatUpdate(BaseModel):
    client_id: str
    ip: str

class ScheduleUpdate(BaseModel):
    client_id: str
    disable_time: str
    enable_time: str

@router.post("/clients/register")
async def register_client(data: ClientRegistration, db: Session = Depends(SessionLocal)):
    try:
        existing_client = db.query(Client).filter(Client.client_id == data.client_id).first()
        if existing_client:
            existing_client.ip = data.ip
            existing_client.last_heartbeat = datetime.utcnow()
        else:
            new_client = Client(
                client_id=data.client_id,
                ip=data.ip,
                state="unpaused",
                registered_at=datetime.utcnow(),
                last_heartbeat=datetime.utcnow()
            )
            db.add(new_client)
        db.commit()
        return {"status": "success", "client_id": data.client_id}
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Failed to register client: {str(e)}")

@router.post("/clients/heartbeat")
async def update_heartbeat(data: HeartbeatUpdate, db: Session = Depends(SessionLocal)):
    try:
        client = db.query(Client).filter(Client.client_id == data.client_id).first()
        if not client:
            raise HTTPException(status_code=404, detail="Client not registered.")
        client.ip = data.ip
        client.last_heartbeat = datetime.utcnow()
        db.commit()
        return {"status": "success"}
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Failed to update heartbeat: {str(e)}")

@router.post("/schedule")
async def set_schedule(data: ScheduleUpdate, db: Session = Depends(SessionLocal)):
    try:
        datetime.strptime(data.disable_time, "%H:%M")
        datetime.strptime(data.enable_time, "%H:%M")
    except ValueError:
        raise HTTPException(status_code=400, detail="Invalid time format.")

    client = db.query(Client).filter(Client.client_id == data.client_id).first()
    if not client:
        raise HTTPException(status_code=404, detail="Client not found.")

    schedule = db.query(Schedule).filter(Schedule.client_id == client.id).first()
    if schedule:
        schedule.disable_time = data.disable_time
        schedule.enable_time = data.enable_time
    else:
        schedule = Schedule(
            client_id=client.id,
            disable_time=data.disable_time,
            enable_time=data.enable_time
        )
        db.add(schedule)

    db.commit()
    return {"status": "success"}

@router.websocket("/ws/{client_id}")
async def websocket_endpoint(client_id: str, websocket: WebSocket, db: Session = Depends(SessionLocal)):
    """Handle WebSocket connections for real-time updates."""
    await websocket.accept()
    try:
        # Validate the client_id exists
        client = db.query(Client).filter(Client.client_id == client_id).first()
        if not client:
            await websocket.close(code=1008)
            logging.error(f"WebSocket connection denied: Client {client_id} not found.")
            return
        
        connected_clients[client_id] = websocket
        logging.info(f"WebSocket connected: {client_id}")
        
        while True:
            # Listen for incoming messages if required
            message = await websocket.receive_json()
            logging.info(f"Received message from {client_id}: {message}")

    except WebSocketDisconnect:
        logging.warning(f"WebSocket disconnected: {client_id}")
    except Exception as e:
        logging.error(f"WebSocket error for {client_id}: {e}")
    finally:
        # Clean up WebSocket connection
        connected_clients.pop(client_id, None)
        logging.info(f"WebSocket connection closed for client {client_id}.")

@router.get("/clients/state/{client_id}")
async def get_client_state(client_id: str, db: Session = Depends(SessionLocal)):
    """Fetch the current state of a client."""
    client = db.query(Client).filter(Client.client_id == client_id).first()
    if not client:
        raise HTTPException(status_code=404, detail="Client not found.")
    return {"client_id": client.client_id, "state": client.state}

@router.get("/clients/schedule/{client_id}")
async def get_client_schedule(client_id: str, db: Session = Depends(SessionLocal)):
    """Fetch the schedule for a client."""
    client = db.query(Client).filter(Client.client_id == client_id).first()
    if not client:
        raise HTTPException(status_code=404, detail="Client not found.")
    schedule = db.query(Schedule).filter(Schedule.client_id == client.id).first()
    if not schedule:
        raise HTTPException(status_code=404, detail="Schedule not found.")
    return {"disable_time": schedule.disable_time, "enable_time": schedule.enable_time}

