Server Management Directory Report
Generated on: Wed Jan  1 08:45:08 PM EST 2025
===================================

Directory Structure and Permissions:
-----------------------------------
drwxrwxr-x 8 brett brett 4096 Jan  1 18:54 /home/brett/server-management
drwxrwxr-x 2 brett brett 4096 Jan  1 12:19 /home/brett/server-management/templates
-rw-rw-r-- 1 brett brett 1354 Dec 23 20:40 /home/brett/server-management/templates/manage.html
-rw-rw-r-- 1 brett brett 960 Dec 22 16:02 /home/brett/server-management/templates/base.html
-rw-r--r-- 1 root root 5023 Dec 30 19:15 /home/brett/server-management/templates/dashboard.html
-rw-r--r-- 1 root root 1170 Dec 22 16:03 /home/brett/server-management/templates/clients.html
drwxrwxr-x 4 brett brett 4096 Dec 27 22:10 /home/brett/server-management/migrations
-rw-rw-r-- 1 brett brett 38 Dec 27 22:08 /home/brett/server-management/migrations/README
-rw-rw-r-- 1 brett brett 635 Dec 27 22:08 /home/brett/server-management/migrations/script.py.mako
drwxrwxr-x 2 brett brett 4096 Dec 27 22:08 /home/brett/server-management/migrations/versions
-rw-rw-r-- 1 brett brett 2103 Dec 27 22:08 /home/brett/server-management/migrations/env.py
-rwxr-xr-x 1 root root 1804 Dec 25 18:34 /home/brett/server-management/generate_server_report.sh
-rw-r--r-- 1 root root 2762 Dec 22 15:54 /home/brett/server-management/organize_files.py
-rw-rw-r-- 1 brett brett 3705 Dec 27 22:10 /home/brett/server-management/alembic.ini
-rw-rw-r-- 1 brett brett 14355 Jan  1 18:26 /home/brett/server-management/app.py
-rw-r--r-- 1 root root 1051 Dec 31 09:17 /home/brett/server-management/initialize_db.py
drwxr-xr-x 3 root root 4096 Dec 23 10:32 /home/brett/server-management/static
-rw-r--r-- 1 root root 591 Dec 23 10:32 /home/brett/server-management/static/styles.css
drwxr-xr-x 2 root root 4096 Dec 22 16:04 /home/brett/server-management/static/css
-rw-rw-r-- 1 brett brett 2243 Dec 23 17:40 /home/brett/server-management/db.py
-rw-rw-r-- 1 brett brett 3311 Dec 27 12:19 /home/brett/server-management/scheduler.py
drwxrwxr-x 3 brett brett 4096 Dec 23 16:37 /home/brett/server-management/api
-rw-rw-r-- 1 brett brett 1199 Dec 23 16:32 /home/brett/server-management/api/endpoints.py

File Contents:
-----------------------------------
-----------------------------------
File: /home/brett/server-management/templates/manage.html
-----------------------------------
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Client Management Dashboard</title>
    <link rel="stylesheet" href="/static/styles.css">
</head>
<body>
    <header>
        <h1>Client Management Dashboard</h1>
    </header>
    <main>
        <table>
            <thead>
                <tr>
                    <th>Name</th>
                    <th>IP Address</th>
                    <th>State</th>
                    <th>Actions</th>
                </tr>
            </thead>
<tbody>
    {% if clients %}
        {% for client in clients %}
        <tr>
            <td>{{ client[0] }}</td> <!-- Name -->
            <td>{{ client[1] }}</td> <!-- IP -->
            <td>{{ client[2] }}</td> <!-- State -->
            <td>
                <form method="post" action="/block/{{ client[0] }}">
                    <button type="submit">Block</button>
                </form>
                <form method="post" action="/unblock/{{ client[0] }}">
                    <button type="submit">Unblock</button>
                </form>
            </td>
        </tr>
        {% endfor %}
    {% else %}
        <tr>
            <td colspan="4">No clients found.</td>
        </tr>
    {% endif %}
</tbody>
        </table>
    </main>
</body>
</html>

-----------------------------------
File: /home/brett/server-management/templates/base.html
-----------------------------------
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}Client Management{% endblock %}</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/styles.css">
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container-fluid">
            <a class="navbar-brand" href="/">Client Management</a>
            <div class="navbar-nav">
                <a class="nav-link" href="/clients">Clients</a>
            </div>
        </div>
    </nav>
    <div class="container mt-4">
        {% block content %}{% endblock %}
    </div>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/scripts.js"></script>
</body>
</html>

-----------------------------------
File: /home/brett/server-management/templates/dashboard.html
-----------------------------------
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Internet Control Dashboard</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            background-color: #f5f5f5;
        }
        h1 {
            color: #007bff;
            margin-bottom: 20px;
        }
        .table {
            background-color: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }
        th {
            background-color: #007bff;
            color: white;
            text-align: center;
            vertical-align: middle;
        }
        td {
            text-align: center;
            vertical-align: middle;
        }
        .form-control-sm {
            max-width: 200px;
        }
        .btn-sm {
            width: 120px;
        }
        .btn-primary, .btn-secondary, .btn-danger, .btn-success, .btn-warning {
            margin-top: 5px;
        }
        .input-group input {
            text-align: center;
        }
    </style>
</head>
<body>
<div class="container mt-5">
    <h1 class="text-center">Internet Control Dashboard</h1>

    <!-- Error/Feedback Messages -->
    <div id="error-message" class="alert alert-danger" style="display: none;"></div>
    <div id="success-message" class="alert alert-success" style="display: none;"></div>

    <!-- Client Table -->
    <table class="table table-striped table-bordered mt-4">
        <thead>
        <tr>
            <th>Client Name</th>
            <th>Friendly Name</th>
            <th>IP Address</th>
            <th>State</th>
            <th>Downtime Schedule</th>
            <th>Actions</th>
        </tr>
        </thead>
        <tbody>
        {% for client in clients %}
        <tr>
            <!-- Client Name -->
            <td>{{ client.name }}</td>
            
            <!-- Friendly Name -->
            <td>
                <form method="post" action="/clients/rename" class="d-inline">
                    <input type="hidden" name="client_id" value="{{ client.client_id }}">
                    <input type="text" name="new_name" class="form-control form-control-sm"
                           value="{{ client.friendly_name or '' }}" placeholder="Set friendly name">
                    <button class="btn btn-secondary btn-sm mt-2" type="submit">Update</button>
                </form>
            </td>
            
            <!-- IP Address -->
            <td>{{ client.ip }}</td>
            
            <!-- Client State -->
            <td>
                {% if client.state == "unpaused" %}
                <span class="badge bg-success">Active</span>
                {% else %}
                <span class="badge bg-danger">Paused</span>
                {% endif %}
            </td>
            
            <!-- Downtime Schedule -->
            <td>
                <form method="post" action="/schedule">
                    <input type="hidden" name="client_id" value="{{ client.client_id }}">
                    <div class="input-group input-group-sm">
                        <input type="time" name="disable_time" class="form-control"
                               value="{{ client.schedules[0].disable_time if client.schedules else '' }}" required>
                        <input type="time" name="enable_time" class="form-control"
                               value="{{ client.schedules[0].enable_time if client.schedules else '' }}" required>
                        <button class="btn btn-primary btn-sm" type="submit">Set</button>
                    </div>
                </form>
            </td>
            
            <!-- Actions -->
            <td>
                <form method="post" action="/control" class="d-inline">
                    <input type="hidden" name="client_id" value="{{ client.client_id }}">
                    <input type="hidden" name="pause" value="true">
                    <button class="btn btn-danger btn-sm">Pause</button>
                </form>
                <form method="post" action="/control" class="d-inline">
                    <input type="hidden" name="client_id" value="{{ client.client_id }}">
                    <input type="hidden" name="pause" value="false">
                    <button class="btn btn-success btn-sm">Unpause</button>
                </form>
                <form method="post" action="/clients/delete" class="d-inline">
                    <input type="hidden" name="client_id" value="{{ client.client_id }}">
                    <button class="btn btn-warning btn-sm">Delete</button>
                </form>
            </td>
        </tr>
        {% endfor %}
        </tbody>
    </table>
</div>

<!-- Include Bootstrap JavaScript -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>

-----------------------------------
File: /home/brett/server-management/templates/clients.html
-----------------------------------
{% extends "base.html" %}
{% block title %}Manage Clients{% endblock %}
{% block content %}
<h2>Clients</h2>
<table class="table table-striped">
    <thead>
        <tr>
            <th>Name</th>
            <th>IP</th>
            <th>Last Seen</th>
            <th>Status</th>
            <th>Action</th>
        </tr>
    </thead>
    <tbody>
        {% for client in clients %}
        <tr>
            <td>{{ client.name }}</td>
            <td>{{ client.ip }}</td>
            <td>{{ client.last_seen }}</td>
            <td>{{ client.status }}</td>
            <td>
                <form action="/clients/control" method="post" class="d-inline">
                    <input type="hidden" name="name" value="{{ client.name }}">
                    <select name="action" class="form-select form-select-sm">
                        <option value="pause">Pause</option>
                        <option value="unpause">Unpause</option>
                    </select>
                    <button type="submit" class="btn btn-primary btn-sm">Submit</button>
                </form>
            </td>
        </tr>
        {% endfor %}
    </tbody>
</table>
{% endblock %}

-----------------------------------
File: /home/brett/server-management/migrations/README
-----------------------------------
Generic single-database configuration.
-----------------------------------
File: /home/brett/server-management/migrations/script.py.mako
-----------------------------------
"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision: str = ${repr(up_revision)}
down_revision: Union[str, None] = ${repr(down_revision)}
branch_labels: Union[str, Sequence[str], None] = ${repr(branch_labels)}
depends_on: Union[str, Sequence[str], None] = ${repr(depends_on)}


def upgrade() -> None:
    ${upgrades if upgrades else "pass"}


def downgrade() -> None:
    ${downgrades if downgrades else "pass"}

-----------------------------------
File: /home/brett/server-management/migrations/env.py
-----------------------------------
from logging.config import fileConfig

from sqlalchemy import engine_from_config
from sqlalchemy import pool

from alembic import context

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
target_metadata = None

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    connectable = engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection, target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()

-----------------------------------
File: /home/brett/server-management/generate_server_report.sh
-----------------------------------
#!/bin/bash

# Define the directory to scan and the output file
TARGET_DIR="/home/brett/server-management"
OUTPUT_FILE="server_management_report.txt"

# Start the report
{
    echo "Server Management Directory Report"
    echo "Generated on: $(date)"
    echo "==================================="
    echo ""
} > "$OUTPUT_FILE"

# Verify the directory exists
if [ ! -d "$TARGET_DIR" ]; then
    echo "Error: Directory $TARGET_DIR does not exist." >> "$OUTPUT_FILE"
    echo "Report generation failed." >> "$OUTPUT_FILE"
    exit 1
fi

# List directory structure and permissions, excluding venv, __pycache__ directories, .db files, and the output file
{
    echo "Directory Structure and Permissions:"
    echo "-----------------------------------"
    find "$TARGET_DIR" \
        -path "$TARGET_DIR/venv" -prune -o \
        -path "*/__pycache__" -prune -o \
        -name "$(basename "$OUTPUT_FILE")" -prune -o \
        -name "*.db" -prune -o \
        -exec ls -ld {} \;
    echo ""
} >> "$OUTPUT_FILE"

# Include file contents for all files, excluding venv, __pycache__ directories, .db files, and the output file
{
    echo "File Contents:"
    echo "-----------------------------------"
    find "$TARGET_DIR" \
        -path "$TARGET_DIR/venv" -prune -o \
        -path "*/__pycache__" -prune -o \
        -name "$(basename "$OUTPUT_FILE")" -prune -o \
        -name "*.db" -prune -o \
        -type f -print | while IFS= read -r file; do
        echo "-----------------------------------"
        echo "File: $file"
        echo "-----------------------------------"
        if [ -r "$file" ]; then
            cat "$file"
        else
            echo "Error: File not readable."
        fi
        echo ""
    done
} >> "$OUTPUT_FILE"

# Notify the user
echo "Report generated: $OUTPUT_FILE"

-----------------------------------
File: /home/brett/server-management/organize_files.py
-----------------------------------
import os
import shutil

# Define the target directory structure
directory_structure = {
    "static": {
        "css": [],
        "js": []
    },
    "templates": ["base.html", "clients.html"],
    "api": ["endpoints.py"],
    "": ["app.py", "db.py", "scheduler.py"],
    "venv": [],  # Assume virtual environment already exists
}

# Source directory where all files are currently located
source_dir = "/home/brett/server-management"
# Destination directory (can be the same as source or a new one)
destination_dir = "/home/brett/server-management"

# Create the destination directory structure
def create_structure():
    print("Creating directory structure...")
    for folder, files in directory_structure.items():
        dir_path = os.path.join(destination_dir, folder)
        os.makedirs(dir_path, exist_ok=True)
        print(f"Created directory: {dir_path}")

# Move files to the correct locations
def move_files():
    print("Organizing files...")
    for folder, files in directory_structure.items():
        target_folder = os.path.join(destination_dir, folder)
        for file_name in files:
            source_file = os.path.join(source_dir, file_name)
            target_file = os.path.join(target_folder, file_name)
            if os.path.exists(source_file):
                if os.path.exists(target_file):
                    print(f"Skipping {file_name}: Already exists in {target_folder}")
                else:
                    shutil.move(source_file, target_file)
                    print(f"Moved {file_name} to {target_folder}")
            else:
                print(f"Warning: {file_name} not found in {source_dir}")

# Copy venv if exists
def copy_venv():
    source_venv = os.path.join(source_dir, "venv")
    target_venv = os.path.join(destination_dir, "venv")
    if os.path.exists(source_venv):
        if os.path.exists(target_venv):
            print("Skipping virtual environment: Already exists.")
        else:
            print("Copying virtual environment...")
            shutil.copytree(source_venv, target_venv, dirs_exist_ok=True)
            print("Virtual environment copied.")
    else:
        print("Warning: venv not found in source directory.")

if __name__ == "__main__":
    # Confirm with the user
    print(f"Source directory: {source_dir}")
    print(f"Destination directory: {destination_dir}")
    confirm = input("Proceed with organizing files? (yes/no): ").strip().lower()
    if confirm == "yes":
        # Ensure destination directory exists
        os.makedirs(destination_dir, exist_ok=True)
        
        # Execute organization
        create_structure()
        move_files()
        copy_venv()
        print("File organization complete!")
    else:
        print("Operation canceled.")

-----------------------------------
File: /home/brett/server-management/alembic.ini
-----------------------------------
# A generic, single database configuration.

[alembic]
# path to migration scripts
# Use forward slashes (/) also on windows to provide an os agnostic path
script_location = migrations

# template used to generate migration file names; The default value is %%(rev)s_%%(slug)s
# Uncomment the line below if you want the files to be prepended with date and time
# see https://alembic.sqlalchemy.org/en/latest/tutorial.html#editing-the-ini-file
# for all available tokens
# file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s

# sys.path path, will be prepended to sys.path if present.
# defaults to the current working directory.
prepend_sys_path = .

# timezone to use when rendering the date within the migration file
# as well as the filename.
# If specified, requires the python>=3.9 or backports.zoneinfo library.
# Any required deps can installed by adding `alembic[tz]` to the pip requirements
# string value is passed to ZoneInfo()
# leave blank for localtime
# timezone =

# max length of characters to apply to the "slug" field
# truncate_slug_length = 40

# set to 'true' to run the environment during
# the 'revision' command, regardless of autogenerate
# revision_environment = false

# set to 'true' to allow .pyc and .pyo files without
# a source .py file to be detected as revisions in the
# versions/ directory
# sourceless = false

# version location specification; This defaults
# to migrations/versions.  When using multiple version
# directories, initial revisions must be specified with --version-path.
# The path separator used here should be the separator specified by "version_path_separator" below.
# version_locations = %(here)s/bar:%(here)s/bat:migrations/versions

# version path separator; As mentioned above, this is the character used to split
# version_locations. The default within new alembic.ini files is "os", which uses os.pathsep.
# If this key is omitted entirely, it falls back to the legacy behavior of splitting on spaces and/or commas.
# Valid values for version_path_separator are:
#
# version_path_separator = :
# version_path_separator = ;
# version_path_separator = space
# version_path_separator = newline
version_path_separator = os  # Use os.pathsep. Default configuration used for new projects.

# set to 'true' to search source files recursively
# in each "version_locations" directory
# new in Alembic version 1.10
# recursive_version_locations = false

# the output encoding used when revision files
# are written from script.py.mako
# output_encoding = utf-8
sqlalchemy.url = sqlite:///server.db


[post_write_hooks]
# post_write_hooks defines scripts or Python functions that are run
# on newly generated revision scripts.  See the documentation for further
# detail and examples

# format using "black" - use the console_scripts runner, against the "black" entrypoint
# hooks = black
# black.type = console_scripts
# black.entrypoint = black
# black.options = -l 79 REVISION_SCRIPT_FILENAME

# lint with attempts to fix using "ruff" - use the exec runner, execute a binary
# hooks = ruff
# ruff.type = exec
# ruff.executable = %(here)s/.venv/bin/ruff
# ruff.options = --fix REVISION_SCRIPT_FILENAME

# Logging configuration
[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARNING
handlers = console
qualname =

[logger_sqlalchemy]
level = WARNING
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S

-----------------------------------
File: /home/brett/server-management/app.py
-----------------------------------
from fastapi import FastAPI, Request, Form, HTTPException, WebSocket, WebSocketDisconnect, Depends
from fastapi.responses import RedirectResponse, HTMLResponse
from fastapi.templating import Jinja2Templates
from fastapi.staticfiles import StaticFiles
from sqlalchemy.orm import sessionmaker
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, String, ForeignKey, DateTime
from sqlalchemy.orm import relationship
from pydantic import BaseModel
import datetime
import logging
import json
import asyncio
import uuid

# Initialize FastAPI and database
app = FastAPI()
templates = Jinja2Templates(directory="templates")
app.mount("/static", StaticFiles(directory="static"), name="static")

DATABASE_URL = "sqlite:///server.db"
engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# Global variable to store connected clients
connected_clients = {}  # Format: {client_id: {"websocket": websocket, "queue": asyncio.Queue()}}

# Define database models
class Client(Base):
    __tablename__ = "clients"
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, unique=True, nullable=False)
    friendly_name = Column(String, nullable=True)
    ip = Column(String, nullable=False)
    state = Column(String, default="unpaused")
    registered_at = Column(DateTime, default=datetime.datetime.utcnow)
    last_heartbeat = Column(DateTime)
    client_id = Column(String, unique=True, default=lambda: str(uuid.uuid4()))

class Schedule(Base):
    __tablename__ = "schedules"
    id = Column(Integer, primary_key=True, index=True)
    client_id = Column(Integer, ForeignKey("clients.id"), nullable=False)
    disable_time = Column(String, nullable=False)
    enable_time = Column(String, nullable=False)
    client = relationship("Client", back_populates="schedules")

Client.schedules = relationship("Schedule", back_populates="client", cascade="all, delete-orphan")

Base.metadata.create_all(bind=engine)

# Dependency for database session
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# Pydantic models for WebSocket communication
class WebSocketMessage(BaseModel):
    action: str
    status: str | None = None

@app.on_event("startup")
async def startup_event():
    """Startup event to initialize state enforcement."""
    asyncio.create_task(enforce_downtime())

async def enforce_downtime():
    """Periodically enforce downtime schedules."""
    while True:
        db = SessionLocal()
        try:
            now = datetime.datetime.now().time()
            schedules = db.query(Schedule).all()
            for schedule in schedules:
                client = db.query(Client).filter(Client.id == schedule.client_id).first()
                if not client:
                    continue

                disable_time = datetime.datetime.strptime(schedule.disable_time, "%H:%M").time()
                enable_time = datetime.datetime.strptime(schedule.enable_time, "%H:%M").time()
                in_downtime = disable_time <= now <= enable_time or (
                    disable_time > enable_time and (now >= disable_time or now <= enable_time)
                )

                if in_downtime and client.state != "paused":
                    client.state = "paused"
                    db.commit()
                    client_info = connected_clients.get(client.client_id)
                    if client_info:
                        await client_info["websocket"].send_json({"action": "state_update", "paused": True})
                        logging.debug(f"Sent state_update (paused=True) to client {client.client_id}")
                elif not in_downtime and client.state != "unpaused":
                    client.state = "unpaused"
                    db.commit()
                    client_info = connected_clients.get(client.client_id)
                    if client_info:
                        await client_info["websocket"].send_json({"action": "state_update", "paused": False})
                        logging.debug(f"Sent state_update (paused=False) to client {client.client_id}")
        except Exception as e:
            logging.error(f"Error enforcing downtime: {e}")
        finally:
            db.close()
        await asyncio.sleep(60)

@app.websocket("/ws/{client_id}")
async def websocket_endpoint(websocket: WebSocket, client_id: str, db: SessionLocal = Depends(get_db)):
    await websocket.accept()
    logging.info(f"WebSocket connection established with client_id: {client_id}")

    try:
        # Validate the provided client_id against the database
        client = db.query(Client).filter(Client.client_id == client_id).first()

        if client:
            # Known client: Update IP address and mark as active
            logging.info(f"Reusing existing client_id: {client_id} for IP: {websocket.client.host}")
            client.ip = websocket.client.host
            client.last_heartbeat = datetime.datetime.utcnow()  # Update heartbeat on connect
            db.commit()
        else:
            # Unknown client_id: Treat as invalid and close the connection
            logging.warning(f"Unknown client_id: {client_id}. Rejecting connection.")
            await websocket.close(code=1008, reason="Invalid client_id")
            return

        # Track the WebSocket connection in the global dictionary
        connected_clients[client_id] = {"websocket": websocket, "queue": asyncio.Queue()}

        # Main WebSocket message handling loop
        while True:
            try:
                data = await websocket.receive_json()
                logging.debug(f"Message received from client {client_id}: {data}")

                # Handle "register" action
                if data.get("action") == "register":
                    client_id_from_client = data.get("client_id")
                    if client_id_from_client != client_id:
                        logging.warning(f"Client {client_id} tried to register with mismatched ID: {client_id_from_client}. Ignoring.")
                        continue

                # Handle other actions
                elif data.get("action") == "state_update":
                    client_state = data.get("state")
                    logging.info(f"Client {client_id} state updated to: {client_state}")

                elif data.get("action") == "update_name":
                    new_name = data.get("new_name")
                    if new_name:
                        client.name = new_name
                        db.commit()
                        logging.info(f"Client {client_id} name updated to: {new_name}")
                        await websocket.send_json({"action": "update_name", "new_name": new_name})

                else:
                    logging.warning(f"Unknown action received from client {client_id}: {data}")

            except Exception as e:
                logging.error(f"Error processing message from client {client_id}: {e}")

    except WebSocketDisconnect:
        logging.warning(f"Client {client_id} disconnected.")
    except Exception as e:
        logging.error(f"Error in WebSocket handler for client {client_id}: {e}")
    finally:
        # Clean up the connection from the global dictionary
        connected_clients.pop(client_id, None)
        db.close()

@app.get("/", response_class=HTMLResponse)
async def dashboard(request: Request, db: SessionLocal = Depends(get_db)):
    try:
        clients = db.query(Client).all()
        return templates.TemplateResponse("dashboard.html", {"request": request, "clients": clients})
    except Exception as e:
        logging.error(f"Failed to load dashboard: {e}")
        raise HTTPException(status_code=500, detail="Failed to load dashboard.")

@app.post("/clients/update_state")
async def update_client_state(client_id: str, db: SessionLocal = Depends(get_db)):
    """Manually update a client's state."""
    client = db.query(Client).filter(Client.client_id == client_id).first()
    if not client:
        raise HTTPException(status_code=404, detail="Client not found.")
    client_info = connected_clients.get(client.client_id)
    if client_info:
        schedule = client.schedules[0] if client.schedules else None
        await client_info["websocket"].send_json(
            {
                "action": "state_update",
                "paused": client.state == "paused",
                "schedule": {
                    "disable_time": schedule.disable_time if schedule else None,
                    "enable_time": schedule.enable_time if schedule else None,
                },
            }
        )
    return {"status": "success"}

@app.post("/control")
async def control_client(pause: bool = Form(...), client_id: str = Form(...), db: SessionLocal = Depends(get_db)):
    """Pause or unpause a client."""
    client = db.query(Client).filter(Client.client_id == client_id).first()
    if not client:
        raise HTTPException(status_code=404, detail="Client not found.")
    client.state = "paused" if pause else "unpaused"
    db.commit()
    logging.info(f"Client {client.name} state updated to {client.state}")

    # Notify the client via WebSocket
    client_info = connected_clients.get(client_id)
    if client_info:
        try:
            await client_info["websocket"].send_json({"action": "state_update", "state": client.state})
        except Exception as e:
            logging.error(f"Failed to send state update to client {client_id}: {e}")
            connected_clients.pop(client_id, None)

    return RedirectResponse(url="/", status_code=303)

@app.post("/heartbeat.php")
async def heartbeat(client_id: str = Form(...), db: SessionLocal = Depends(get_db)):
    """Handle periodic heartbeat requests from clients."""
    logging.debug(f"Received heartbeat from client_id: {client_id}")
    try:
        client = db.query(Client).filter(Client.client_id == client_id).first()
        if not client:
            logging.warning(f"Heartbeat received for unknown client_id: {client_id}")
            raise HTTPException(status_code=404, detail="Client not found.")

        # Update the last_heartbeat timestamp
        client.last_heartbeat = datetime.datetime.utcnow()
        db.commit()

        logging.info(f"Heartbeat acknowledged for client_id: {client_id}")
        return {"status": "success", "message": "Heartbeat acknowledged."}
    except Exception as e:
        logging.error(f"Error handling heartbeat for client_id: {client_id}, error: {e}")
        raise HTTPException(status_code=500, detail="Error processing heartbeat.")

@app.post("/schedule")
async def set_schedule(client_id: str = Form(...), disable_time: str = Form(...), enable_time: str = Form(...), db: SessionLocal = Depends(get_db)):
    """Set a downtime schedule for a client."""
    client = db.query(Client).filter(Client.client_id == client_id).first()
    if not client:
        raise HTTPException(status_code=404, detail="Client not found.")
    schedule = db.query(Schedule).filter(Schedule.client_id == client.id).first()
    if not schedule:
        schedule = Schedule(client_id=client.id, disable_time=disable_time, enable_time=enable_time)
        db.add(schedule)
    else:
        schedule.disable_time = disable_time
        schedule.enable_time = enable_time
    db.commit()

    client_websocket = connected_clients.get(client_id)
    if client_websocket:
        try:
            await client_websocket.send_text(json.dumps({"schedule": {"disable_time": disable_time, "enable_time": enable_time}}))
        except Exception:
            logging.error(f"Failed to notify client {client.name} of schedule change.")
    return RedirectResponse(url="/", status_code=303)

@app.post("/clients/rename")
async def rename_client(client_id: str = Form(...), new_name: str = Form(...), db: SessionLocal = Depends(get_db)):
    """Rename a client."""
    client = db.query(Client).filter(Client.client_id == client_id).first()
    if not client:
        raise HTTPException(status_code=404, detail="Client not found.")
    if new_name != client.name and db.query(Client).filter(Client.friendly_name == new_name).first():
        raise HTTPException(status_code=400, detail="Friendly name already in use.")
    old_name = client.name
    client.name = new_name
    db.commit()

    # Notify the client via WebSocket
    client_info = connected_clients.get(client_id)
    if client_info:
        websocket = client_info.get("websocket")  # Retrieve the WebSocket object
        if websocket:  # Ensure the WebSocket is still connected
            try:
                await websocket.send_json({"action": "update_name", "new_name": new_name})
            except Exception as e:
                logging.error(f"Failed to send name update to client {client_id}: {e}")
                connected_clients.pop(client_id, None)

    logging.info(f"Client renamed from '{old_name}' to '{new_name}'")
    return RedirectResponse(url="/", status_code=303)

@app.post("/clients/delete")
async def delete_client(client_id: str = Form(...), db: SessionLocal = Depends(get_db)):
    """Delete a client."""
    client = db.query(Client).filter(Client.client_id == client_id).first()
    if not client:
        raise HTTPException(status_code=404, detail="Client not found.")
    db.delete(client)
    db.commit()
    return RedirectResponse(url="/", status_code=303)

async def handle_client_messages(client_id, websocket):
    """Handle client WebSocket messages."""
    while True:
        try:
            message = await connected_clients[client_id]["queue"].get()
            for retry in range(3):
                try:
                    await websocket.send_json(message)
                    logging.info(f"Sent message to client {client_id}: {message}")
                    break
                except Exception as e:
                    if retry < 2:
                        await asyncio.sleep(2 ** retry)
                        continue
                    logging.error(f"Failed to send message to client {client_id}: {e}")
                    break
        except Exception as e:
            logging.error(f"Unexpected error in client message handling: {e}")
            break

-----------------------------------
File: /home/brett/server-management/initialize_db.py
-----------------------------------
import sqlite3
from contextlib import closing

DB_PATH = "server.db"

# Initialize database
def init_db():
    with closing(sqlite3.connect(DB_PATH)) as conn, conn:
        conn.executescript(
            """
            CREATE TABLE IF NOT EXISTS clients (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT UNIQUE NOT NULL,
                friendly_name TEXT UNIQUE,
                ip TEXT NOT NULL,
                state TEXT DEFAULT 'unpaused',
                registered_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                last_heartbeat DATETIME,
                client_id TEXT UNIQUE NOT NULL
            );

            CREATE TABLE IF NOT EXISTS schedules (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                client_id INTEGER NOT NULL,
                disable_time TEXT NOT NULL,
                enable_time TEXT NOT NULL,
                FOREIGN KEY (client_id) REFERENCES clients (id) ON DELETE CASCADE
            );
            """
        )

if __name__ == "__main__":
    init_db()

-----------------------------------
File: /home/brett/server-management/static/styles.css
-----------------------------------
body {
    font-family: Arial, sans-serif;
    background-color: #f9f9f9;
    margin: 0;
    padding: 0;
}
header {
    background-color: #333;
    color: white;
    padding: 1em 0;
    text-align: center;
}
table {
    width: 100%;
    border-collapse: collapse;
    margin: 20px 0;
}
table, th, td {
    border: 1px solid #ddd;
}
th, td {
    padding: 8px;
    text-align: left;
}
th {
    background-color: #f4f4f4;
}
button {
    padding: 5px 10px;
    background-color: #007bff;
    color: white;
    border: none;
    cursor: pointer;
}
button:hover {
    background-color: #0056b3;
}

-----------------------------------
File: /home/brett/server-management/db.py
-----------------------------------
import sqlite3
from contextlib import closing

DB_PATH = "server.db"

# Initialize database
def init_db():
    with closing(sqlite3.connect(DB_PATH)) as conn, conn:
        conn.executescript("""
        CREATE TABLE IF NOT EXISTS clients (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT UNIQUE NOT NULL,
            ip TEXT NOT NULL,
            state TEXT DEFAULT 'unpaused',
            registered_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            last_heartbeat DATETIME
        );

        CREATE TABLE IF NOT EXISTS schedules (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            client_id INTEGER NOT NULL,
            disable_time TEXT NOT NULL,
            enable_time TEXT NOT NULL,
            FOREIGN KEY (client_id) REFERENCES clients (id) ON DELETE CASCADE
        );
        """)

# Query utilities
def execute_query(query, params=(), fetch_one=False, fetch_all=False):
    try:
        with closing(sqlite3.connect(DB_PATH)) as conn, conn:
            cursor = conn.execute(query, params)
            if fetch_one:
                return cursor.fetchone()
            if fetch_all:
                return cursor.fetchall()
            return cursor.lastrowid
    except sqlite3.DatabaseError as e:
        print(f"Database error: {e}")
        return None

# Client-specific utilities
def add_client(name, ip, state="unpaused"):
    query = """
    INSERT INTO clients (name, ip, state)
    VALUES (?, ?, ?)
    ON CONFLICT(name) DO UPDATE SET
        ip = ?,
        state = ?;
    """
    execute_query(query, (name, ip, state, ip, state))

def get_client_by_name(name):
    query = "SELECT * FROM clients WHERE name = ?"
    return execute_query(query, (name,), fetch_one=True)

# Schedule-specific utilities
def add_schedule(client_id, disable_time, enable_time):
    query = """
    INSERT INTO schedules (client_id, disable_time, enable_time)
    VALUES (?, ?, ?);
    """
    execute_query(query, (client_id, disable_time, enable_time))

def get_schedule_by_client_name(name):
    query = """
    SELECT s.disable_time, s.enable_time
    FROM schedules s
    JOIN clients c ON s.client_id = c.id
    WHERE c.name = ?;
    """
    return execute_query(query, (name,), fetch_one=True)

-----------------------------------
File: /home/brett/server-management/scheduler.py
-----------------------------------
import asyncio
import json
from apscheduler.schedulers.background import BackgroundScheduler
from datetime import datetime
from fastapi import APIRouter, WebSocket
from typing import Dict

# Router for FastAPI endpoints
router = APIRouter()

# Connected WebSocket clients
connected_clients: Dict[str, WebSocket] = {}

# Existing schedules
SCHEDULES = {
    "PC1": {"disable_time": "22:00", "enable_time": "06:00"},
}

async def rebroadcast_schedules():
    """Periodically rebroadcast the schedules to all connected clients."""
    while True:
        for client_name, schedule in SCHEDULES.items():
            if client_name in connected_clients:
                try:
                    await connected_clients[client_name].send(json.dumps({"schedule": schedule}))
                    print(f"Schedule rebroadcast to {client_name}: {schedule}")
                except Exception as e:
                    print(f"Failed to send schedule to {client_name}: {e}")
        await asyncio.sleep(300)  # Rebroadcast every 5 minutes


@router.post("/schedule")
async def update_schedule(client_name: str, disable_time: str, enable_time: str):
    """Update the downtime schedule for a client."""
    if client_name in SCHEDULES:
        SCHEDULES[client_name]["disable_time"] = disable_time
        SCHEDULES[client_name]["enable_time"] = enable_time
    else:
        SCHEDULES[client_name] = {"disable_time": disable_time, "enable_time": enable_time}
    print(f"Schedule updated for {client_name}: {SCHEDULES[client_name]}")
    return {"status": "success", "schedule": SCHEDULES[client_name]}


@router.websocket("/ws/{client_name}")
async def websocket_endpoint(client_name: str, websocket: WebSocket):
    """Handle WebSocket connections from clients."""
    await websocket.accept()
    connected_clients[client_name] = websocket
    print(f"{client_name} connected via WebSocket.")

    # Send the initial schedule upon connection
    if client_name in SCHEDULES:
        try:
            await websocket.send(json.dumps({"schedule": SCHEDULES[client_name]}))
            print(f"Initial schedule sent to {client_name}: {SCHEDULES[client_name]}")
        except Exception as e:
            print(f"Failed to send initial schedule to {client_name}: {e}")

    try:
        while True:
            message = await websocket.receive_text()
            print(f"Message received from {client_name}: {message}")
            data = json.loads(message)

            # Handle resync request
            if data.get("action") == "resync":
                if client_name in SCHEDULES:
                    await websocket.send(json.dumps({"schedule": SCHEDULES[client_name]}))
                    print(f"Resync schedule sent to {client_name}: {SCHEDULES[client_name]}")

    except Exception as e:
        print(f"WebSocket connection with {client_name} closed: {e}")

    finally:
        if client_name in connected_clients:
            del connected_clients[client_name]
        print(f"{client_name} disconnected.")


# Background scheduler for periodic tasks
scheduler = BackgroundScheduler()
scheduler.add_job(rebroadcast_schedules, "interval", seconds=300)  # Rebroadcast every 5 minutes
scheduler.start()

# Ensure the scheduler is shutdown gracefully
import atexit
atexit.register(lambda: scheduler.shutdown())

-----------------------------------
File: /home/brett/server-management/api/endpoints.py
-----------------------------------
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from db import (
    add_client,
    get_client_by_name,
    execute_query
)

# Define your API router
router = APIRouter()

# Models
class Client(BaseModel):
    name: str
    ip: str
    state: str = "unpaused"  # Default state

# Register a client
@router.post("/clients/register")
async def register_client(client: Client):
    """
    Registers a new client or updates an existing client's IP and state.
    """
    add_client(client.name, client.ip, client.state)
    return {"status": "success", "message": "Client registered successfully."}

# Update client's heartbeat
@router.post("/clients/heartbeat")
async def update_heartbeat(client: Client):
    """
    Updates the last known heartbeat and state for a client.
    """
    db_client = get_client_by_name(client.name)
    if not db_client:
        return {"error": "Client not registered."}
    query = """
    UPDATE clients
    SET ip = ?, state = ?, last_heartbeat = CURRENT_TIMESTAMP
    WHERE name = ?
    """
    execute_query(query, (client.ip, client.state, client.name))
    return {"status": "success", "message": "Heartbeat updated successfully."}

